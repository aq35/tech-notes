import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkGfm from 'remark-gfm';
import { visit } from 'unist-util-visit';
import { Node } from 'unist';
import { Table, TableRow, TableCell } from 'mdast';

// 型定義
interface ParseResult<T> {
  success: boolean;
  data: T[];
  error?: string;
}

interface TableParserOptions {
  strictValidation?: boolean;
  allowEmptyCells?: boolean;
  trimWhitespace?: boolean;
}

interface TableNode extends Node {
  type: 'table';
  children: TableRow[];
}

interface RowData {
  [key: string]: string | number | null;
}

type ValidationResult = {
  isValid: boolean;
  errors: string[];
};

// カスタムエラークラス
class TableParseError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'TableParseError';
  }
}

/**
 * マークダウンテーブルパーサークラス
 */
export class MarkdownTableParser {
  private processor: ReturnType<typeof unified>;
  private options: Required<TableParserOptions>;

  constructor(options: TableParserOptions = {}) {
    this.options = {
      strictValidation: options.strictValidation ?? true,
      allowEmptyCells: options.allowEmptyCells ?? false,
      trimWhitespace: options.trimWhitespace ?? true,
    };

    this.processor = unified()
      .use(remarkParse)
      .use(remarkGfm)
      .use(this.extractTables);
  }

  /**
   * テーブルを抽出するremarkプラグイン
   */
  private extractTables = () => (tree: Node): RowData[] => {
    const tables: RowData[][] = [];

    visit(tree, 'table', (node: TableNode) => {
      try {
        const [headerRow, ...dataRows] = node.children;
        
        // ヘッダーの抽出と検証
        const headers = this.extractRowContent(headerRow);
        this.validateHeaders(headers);
        
        // データ行の抽出と変換
        const data = dataRows.map((row, rowIndex) => {
          const values = this.extractRowContent(row);
          this.validateRow(values, headers, rowIndex);
          return this.createRowObject(headers, values);
        });

        tables.push(data);
      } catch (error) {
        if (error instanceof TableParseError) {
          throw error;
        }
        throw new TableParseError('テーブルの解析中にエラーが発生しました');
      }
    });

    return tables[0] || [];
  };

  /**
   * 行の内容を抽出
   */
  private extractRowContent(row: TableRow): string[] {
    return row.children.map(cell => {
      const content = this.getCellContent(cell);
      return this.options.trimWhitespace ? content.trim() : content;
    });
  }

  /**
   * セルの内容を取得
   */
  private getCellContent(cell: TableCell): string {
    const textNode = cell.children[0];
    if (!textNode) {
      return this.options.allowEmptyCells ? '' : ' ';
    }
    return 'value' in textNode ? textNode.value : '';
  }

  /**
   * ヘッダーを検証
   */
  private validateHeaders(headers: string[]): ValidationResult {
    const errors: string[] = [];

    if (headers.length === 0) {
      errors.push('ヘッダーが空です');
    }

    const uniqueHeaders = new Set(headers);
    if (uniqueHeaders.size !== headers.length) {
      errors.push('重複するヘッダーが存在します');
    }

    headers.forEach((header, index) => {
      if (!header && this.options.strictValidation) {
        errors.push(`ヘッダー${index + 1}が空です`);
      }
    });

    const isValid = errors.length === 0;
    if (!isValid && this.options.strictValidation) {
      throw new TableParseError(errors.join(', '));
    }

    return { isValid, errors };
  }

  /**
   * データ行を検証
   */
  private validateRow(values: string[], headers: string[], rowIndex: number): ValidationResult {
    const errors: string[] = [];

    if (values.length !== headers.length) {
      errors.push(`行${rowIndex + 1}のカラム数がヘッダーと一致しません`);
    }

    values.forEach((value, index) => {
      if (!value && !this.options.allowEmptyCells) {
        errors.push(`行${rowIndex + 1}のカラム${index + 1}が空です`);
      }
    });

    const isValid = errors.length === 0;
    if (!isValid && this.options.strictValidation) {
      throw new TableParseError(errors.join(', '));
    }

    return { isValid, errors };
  }

  /**
   * ヘッダーと値からオブジェクトを作成
   */
  private createRowObject(headers: string[], values: string[]): RowData {
    const obj: RowData = {};
    headers.forEach((header, index) => {
      const value = values[index];
      obj[header] = value || null;
    });
    return obj;
  }

  /**
   * マークダウンを解析してJSONを返す
   */
  public parse(markdownContent: string): ParseResult<RowData> {
    try {
      const file = this.processor.processSync(markdownContent);
      return {
        success: true,
        data: file.data || []
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : '不明なエラー';
      return {
        success: false,
        data: [],
        error: errorMessage
      };
    }
  }
}

// 使用例
const example = () => {
  const parser = new MarkdownTableParser({
    strictValidation: true,
    allowEmptyCells: false,
    trimWhitespace: true
  });

  const markdown = `
| Name    | Age | City    |
|---------|-----|---------|
| John    | 30  | New York|
| Alice   | 25  | London  |
| Bob     | 35  | Tokyo   |
  `;

  const result = parser.parse(markdown);
  return result;
};

export { MarkdownTableParser, example, type ParseResult, type TableParserOptions, type RowData };